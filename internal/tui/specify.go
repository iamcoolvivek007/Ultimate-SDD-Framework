package tui

import (
	"fmt"
	"strings"

	"github.com/charmbracelet/bubbles/textarea"
	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"ultimate-sdd-framework/internal/agents"
	"ultimate-sdd-framework/internal/gates"
)

type specifyModel struct {
	agent    *agents.Agent
	context  string
	stateMgr *gates.StateManager
	textarea textarea.Model
	input    textinput.Model
	step     int // 0: description, 1: requirements, 2: constraints, 3: review
	specs    map[string]string
	err      error
}

func RunSpecifyTUI(agent *agents.Agent, context string, stateMgr *gates.StateManager) error {
	ta := textarea.New()
	ta.Placeholder = "Describe the feature requirements..."
	ta.Focus()

	ti := textinput.New()
	ti.Placeholder = "Press Enter to continue..."

	m := specifyModel{
		agent:    agent,
		context:  context,
		stateMgr: stateMgr,
		textarea: ta,
		input:    ti,
		step:     0,
		specs:    make(map[string]string),
	}

	p := tea.NewProgram(m)
	_, err := p.Run()
	return err
}

func (m specifyModel) Init() tea.Cmd {
	return textinput.Blink
}

func (m specifyModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "esc":
			return m, tea.Quit
		case "enter":
			if m.step < 3 {
				// Save current input and move to next step
				m.saveCurrentStep()
				m.step++
				m.resetForNextStep()
				return m, nil
			} else {
				// Generate final specification
				return m, m.generateSpec()
			}
		case "tab":
			if m.step > 0 {
				m.step--
				m.loadPreviousStep()
				return m, nil
			}
		}
	case error:
		m.err = msg
		return m, nil
	}

	// Handle textarea input
	if m.step < 3 {
		m.textarea, cmd = m.textarea.Update(msg)
	} else {
		m.input, cmd = m.input.Update(msg)
	}

	return m, cmd
}

func (m specifyModel) View() string {
	var b strings.Builder

	title := lipgloss.NewStyle().
		Bold(true).
		Foreground(lipgloss.Color("39")).
		Render("ðŸŽ¯ Feature Specification - Ultimate SDD Framework")

	b.WriteString(title + "\n\n")

	steps := []string{"Description", "Requirements", "Constraints", "Review"}
	for i, step := range steps {
		if i == m.step {
			b.WriteString(fmt.Sprintf("â–¶ï¸  %s\n", step))
		} else if i < m.step {
			b.WriteString(fmt.Sprintf("âœ… %s\n", step))
		} else {
			b.WriteString(fmt.Sprintf("â—‹  %s\n", step))
		}
	}

	b.WriteString("\n")

	switch m.step {
	case 0:
		b.WriteString("Describe the feature you want to build:\n")
		b.WriteString(m.textarea.View())
		b.WriteString("\n\nPress Enter to continue to requirements...")
	case 1:
		b.WriteString("List the functional requirements:\n")
		b.WriteString(m.textarea.View())
		b.WriteString("\n\nPress Enter to continue to constraints...")
	case 2:
		b.WriteString("List any constraints or limitations:\n")
		b.WriteString(m.textarea.View())
		b.WriteString("\n\nPress Enter to review and generate specification...")
	case 3:
		b.WriteString("Review your specification:\n\n")
		spec := m.generateSpecPreview()
		b.WriteString(spec)
		b.WriteString("\n\n" + m.input.View())
		b.WriteString("\n\nPress Enter to save specification, ESC to cancel")
	}

	if m.err != nil {
		b.WriteString("\n\nError: " + m.err.Error())
	}

	b.WriteString("\n\nNavigation: Tab = Previous Step, ESC = Cancel")

	return b.String()
}

func (m *specifyModel) saveCurrentStep() {
	var key string
	switch m.step {
	case 0:
		key = "description"
	case 1:
		key = "requirements"
	case 2:
		key = "constraints"
	}
	m.specs[key] = m.textarea.Value()
}

func (m *specifyModel) resetForNextStep() {
	m.textarea.Reset()
	switch m.step {
	case 1:
		m.textarea.Placeholder = "â€¢ Feature must do X\nâ€¢ User can perform Y\nâ€¢ System handles Z..."
	case 2:
		m.textarea.Placeholder = "â€¢ Timeline: 2 weeks\nâ€¢ Tech stack: Go + React\nâ€¢ Must integrate with API..."
	case 3:
		m.input.Placeholder = "Type 'approve' to save specification..."
		m.input.Focus()
	}
}

func (m *specifyModel) loadPreviousStep() {
	var key string
	switch m.step {
	case 0:
		key = "description"
	case 1:
		key = "requirements"
	case 2:
		key = "constraints"
	}
	if content, exists := m.specs[key]; exists {
		m.textarea.SetValue(content)
	}
}

func (m specifyModel) generateSpecPreview() string {
	return fmt.Sprintf(`# Feature Specification

## Description
%s

## Requirements
%s

## Constraints
%s

---
Generated by %s agent`, m.specs["description"], m.specs["requirements"], m.specs["constraints"], m.agent.Role)
}

func (m specifyModel) generateSpec() tea.Cmd {
	specContent := fmt.Sprintf(`---
title: Feature Specification
created_by: %s
agent: %s
---

# Feature Specification

## Overview
%s

## Functional Requirements
%s

## Constraints & Limitations
%s

## Acceptance Criteria
- [ ] Requirements are implemented correctly
- [ ] Constraints are respected
- [ ] Code follows project standards
- [ ] Tests pass successfully
- [ ] Documentation is complete

---
*Generated by %s agent using Ultimate SDD Framework*`,
		m.agent.Role,
		m.agent.Role,
		m.specs["description"],
		m.specs["requirements"],
		m.specs["constraints"],
		m.agent.Role,
	)

	// Save specification
	specPath := m.stateMgr.GetPhaseOutputPath(gates.PhaseSpecify)
	m.saveSpecToFile(specPath, specContent)

	// Complete phase
	m.stateMgr.CompletePhase([]string{"spec.md"})

	return tea.Quit
}

func (m specifyModel) saveSpecToFile(path, content string) error {
	// This would normally use os.WriteFile, but for demo purposes:
	fmt.Printf("Would save specification to: %s\n", path)
	fmt.Println("Specification content:")
	fmt.Println(content)
	return nil
}
