package cli

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
	"github.com/ultimate-sdd-framework/internal/agents"
	"github.com/ultimate-sdd-framework/internal/gates"
)

func NewPlanCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "plan",
		Short: "Create architecture plan using the Architect agent",
		Long: `Generate a detailed system architecture plan based on specifications.

This command uses the Architect agent to design the system components,
technology choices, data flow, and implementation strategy.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			// Check project state
			stateMgr := gates.NewStateManager(".")
			state, err := stateMgr.LoadState()
			if err != nil {
				return fmt.Errorf("project not initialized: %w", err)
			}

			if state.CurrentPhase != gates.PhaseSpecify {
				return fmt.Errorf("cannot plan: current phase is %s (need %s)", state.CurrentPhase, gates.PhaseSpecify)
			}

			// Check if specification exists
			specPath := stateMgr.GetPhaseOutputPath(gates.PhaseSpecify)
			if _, err := os.Stat(specPath); os.IsNotExist(err) {
				return fmt.Errorf("specification not found: %s", specPath)
			}

			// Load specification
			specContent, err := os.ReadFile(specPath)
			if err != nil {
				return fmt.Errorf("failed to read specification: %w", err)
			}

			// Initialize agent service
			agentSvc := agents.NewAgentService(".")
			if err := agentSvc.Initialize(); err != nil {
				return fmt.Errorf("failed to initialize agent service: %w", err)
			}

			// Validate architect agent is available
			_, err = agentSvc.GetAgentForPhase("plan")
			if err != nil {
				return fmt.Errorf("architect agent not available: %w", err)
			}

			// Transition to plan phase
			if err := stateMgr.TransitionPhase(gates.PhasePlan, "architect"); err != nil {
				return fmt.Errorf("failed to transition to plan phase: %w", err)
			}

			// Generate architecture plan
			planContent, err := agentSvc.GetAgentResponse("architect", "plan", string(specContent))
			if err != nil {
				return fmt.Errorf("failed to generate architecture plan: %w", err)
			}

			// Save plan
			planPath := stateMgr.GetPhaseOutputPath(gates.PhasePlan)
			if err := os.WriteFile(planPath, []byte(planContent), 0644); err != nil {
				return fmt.Errorf("failed to save plan: %w", err)
			}

			// Complete phase
			if err := stateMgr.CompletePhase([]string{filepath.Base(planPath)}); err != nil {
				return fmt.Errorf("failed to complete plan phase: %w", err)
			}

			fmt.Printf("✅ Architecture plan created: %s\n", planPath)
			fmt.Println("Next: Run 'sdd approve' to approve the plan, then 'sdd task' to break it down")

			return nil
		},
	}

	return cmd
}

func generateArchitecturePlan(agent *agents.Agent, context string) string {
	return fmt.Sprintf(`---
title: Architecture Plan
created_by: %s
created_at: Generated by Ultimate SDD Framework
---

# System Architecture Plan

## Overview
This architecture plan outlines the technical approach for implementing the specified feature.

## System Components

### Core Components
1. **API Layer**: RESTful endpoints for feature functionality
2. **Business Logic Layer**: Core feature implementation
3. **Data Layer**: Database models and data access
4. **Presentation Layer**: User interface components

### Supporting Components
1. **Authentication Service**: User management and security
2. **Logging Service**: Audit trails and error tracking
3. **Cache Layer**: Performance optimization
4. **Background Jobs**: Asynchronous processing

## Technology Stack

### Backend
- **Language**: Go (performance, concurrency)
- **Framework**: Gin/Echo (HTTP routing)
- **Database**: PostgreSQL (data integrity)
- **Cache**: Redis (session management)

### Frontend
- **Framework**: React/TypeScript
- **State Management**: Zustand/Redux Toolkit
- **Styling**: Tailwind CSS
- **Build Tool**: Vite

### Infrastructure
- **Containerization**: Docker
- **Orchestration**: Docker Compose (dev), Kubernetes (prod)
- **CI/CD**: GitHub Actions
- **Monitoring**: Prometheus + Grafana

## Data Architecture

### Database Schema
\`\`\`sql
-- Core feature tables
CREATE TABLE feature_entities (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Add indexes and constraints as needed
\`\`\`

### Data Flow
1. User Request → API Gateway → Business Logic
2. Business Logic → Data Access → Database
3. Response ← API Gateway ← Business Logic
4. Cache Layer → Redis for session/performance data

## API Design

### Endpoints
- \`GET /api/v1/features\` - List features
- \`POST /api/v1/features\` - Create feature
- \`GET /api/v1/features/:id\` - Get feature details
- \`PUT /api/v1/features/:id\` - Update feature
- \`DELETE /api/v1/features/:id\` - Delete feature

### Request/Response Format
\`\`\`json
// Request
{
  "name": "Feature Name",
  "description": "Feature description",
  "priority": "high|medium|low"
}

// Response
{
  "id": "uuid",
  "name": "Feature Name",
  "status": "active",
  "created_at": "2024-01-01T00:00:00Z"
}
\`\`\`

## Security Considerations

### Authentication & Authorization
- JWT tokens for session management
- Role-based access control (RBAC)
- API rate limiting
- Input validation and sanitization

### Data Protection
- Encryption at rest (database)
- HTTPS everywhere
- GDPR compliance
- Audit logging

## Performance Requirements

### Response Times
- API responses: <200ms (95th percentile)
- Page load: <2s
- Database queries: <50ms

### Scalability
- Horizontal scaling capability
- Database connection pooling
- CDN for static assets
- Background job processing

## Deployment Strategy

### Environments
1. **Development**: Local development
2. **Staging**: Pre-production testing
3. **Production**: Live environment

### Deployment Process
1. Code review and approval
2. Automated testing (unit, integration)
3. Build and package
4. Deploy to staging
5. Manual testing and approval
6. Deploy to production
7. Monitoring and rollback plan

## Risk Mitigation

### Technical Risks
- **Database Performance**: Implement query optimization and indexing
- **API Scalability**: Use load balancing and caching
- **Security Vulnerabilities**: Regular security audits and updates

### Operational Risks
- **Downtime**: Implement redundancy and failover
- **Data Loss**: Regular backups and disaster recovery
- **Team Knowledge**: Documentation and knowledge sharing

## Implementation Phases

### Phase 1: Foundation (Week 1-2)
- Set up project structure
- Implement basic API endpoints
- Database schema creation
- Authentication setup

### Phase 2: Core Features (Week 3-4)
- Implement business logic
- Create user interface
- Integration testing
- Performance optimization

### Phase 3: Polish & Deploy (Week 5-6)
- UI/UX refinements
- Security hardening
- Production deployment
- Monitoring setup

## Success Metrics
- **Performance**: 95%% of requests <200ms
- **Reliability**: 99.9%% uptime
- **Security**: Zero security incidents
- **User Satisfaction**: >4.5/5 user rating

---
*Generated by %s agent using Ultimate SDD Framework*`, agent.Role, agent.Role)
}