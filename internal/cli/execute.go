package cli

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"ultimate-sdd-framework/internal/agents"
	"ultimate-sdd-framework/internal/gates"
)

func NewExecuteCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "execute",
		Short: "Begin implementation using the Developer agent",
		Long: `Start implementing the approved tasks.

This command uses the Developer agent to guide the implementation
process and track progress against the task breakdown.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			// Check project state
			stateMgr := gates.NewStateManager(".")
			state, err := stateMgr.LoadState()
			if err != nil {
				return fmt.Errorf("project not initialized: %w", err)
			}

			if state.CurrentPhase != gates.PhaseTask {
				return fmt.Errorf("cannot execute: current phase is %s (need %s)", state.CurrentPhase, gates.PhaseTask)
			}

			// Check if tasks exist
			taskPath := stateMgr.GetPhaseOutputPath(gates.PhaseTask)
			if _, err := os.Stat(taskPath); os.IsNotExist(err) {
				return fmt.Errorf("tasks not found: %s", taskPath)
			}

			// Load agents
			agentMgr := agents.NewAgentManager(".")
			if err := agentMgr.LoadAgents(); err != nil {
				return fmt.Errorf("failed to load agents: %w", err)
			}

			// Get developer agent
			devAgent, err := agentMgr.GetAgent("developer")
			if err != nil {
				return fmt.Errorf("developer agent not available: %w", err)
			}

			// Transition to execute phase
			if err := stateMgr.TransitionPhase(gates.PhaseExecute, "developer"); err != nil {
				return fmt.Errorf("failed to transition to execute phase: %w", err)
			}

			// Generate implementation guide
			taskContent, err := os.ReadFile(taskPath)
			if err != nil {
				return fmt.Errorf("failed to read tasks: %w", err)
			}

			context := fmt.Sprintf("Based on task breakdown:\n%s", string(taskContent))
			implContent := generateImplementationGuide(devAgent, context)

			// Save implementation guide
			implPath := stateMgr.GetPhaseOutputPath(gates.PhaseExecute)
			if err := os.WriteFile(implPath, []byte(implContent), 0644); err != nil {
				return fmt.Errorf("failed to save implementation guide: %w", err)
			}

			// Complete phase (in real implementation, this would track actual progress)
			if err := stateMgr.CompletePhase([]string{"implementation.md"}); err != nil {
				return fmt.Errorf("failed to complete execute phase: %w", err)
			}

			fmt.Printf("âœ… Implementation phase started: %s\n", implPath)
			fmt.Println("Next: Work through the implementation tasks, then run 'sdd review'")

			return nil
		},
	}

	return cmd
}

func generateImplementationGuide(agent *agents.Agent, context string) string {
	return fmt.Sprintf(`---
title: Implementation Guide
created_by: %s
created_at: Generated by Ultimate SDD Framework
---

# Implementation Guide

## Development Workflow

### 1. Environment Setup
` + "```" + `bash
# Clone repository
git clone <repository-url>
cd <project-directory>

# Install dependencies
go mod download
npm install

# Set up development database
docker-compose up -d postgres redis

# Run migrations
go run cmd/migrate/main.go up

# Start development server
go run cmd/server/main.go
\`\`\`

### 2. Development Standards

#### Code Style
- Follow Go naming conventions
- Use meaningful variable and function names
- Add comments for complex logic
- Keep functions under 50 lines when possible

#### Commit Guidelines
\`\`\`
feat: add user authentication
fix: resolve login validation bug
docs: update API documentation
test: add unit tests for user service
\`\`\`

#### Testing Requirements
- Unit tests for all functions
- Integration tests for API endpoints
- 80%% code coverage minimum
- All tests must pass before commit

### 3. Implementation Order

#### Phase 1: Foundation (High Priority)
1. **Database Layer**
   - Create entity models
   - Implement repository pattern
   - Set up database connections
   - Write migrations

2. **Core Services**
   - Authentication service
   - User management
   - Basic CRUD operations
   - Input validation

#### Phase 2: Business Logic (High Priority)
1. **Domain Models**
   - Business entity definitions
   - Domain validation rules
   - Business logic encapsulation

2. **API Layer**
   - REST endpoint implementation
   - Request/response handling
   - Error handling middleware
   - API documentation

#### Phase 3: User Interface (Medium Priority)
1. **Component Architecture**
   - Reusable UI components
   - State management setup
   - Routing configuration

2. **Feature Implementation**
   - User authentication flows
   - Core feature functionality
   - Form handling and validation

### 4. Code Quality Checklist

#### Before Commit
- [ ] Code compiles without errors
- [ ] All tests pass
- [ ] Code follows style guidelines
- [ ] No TODO comments left unresolved
- [ ] Documentation updated

#### Code Review Requirements
- [ ] Logic is correct and efficient
- [ ] Error handling is appropriate
- [ ] Security considerations addressed
- [ ] Performance implications reviewed
- [ ] Tests are comprehensive

### 5. Common Patterns

#### Error Handling
\`\`\`go
func (s *Service) GetUser(id string) (*User, error) {
    user, err := s.repo.GetByID(id)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %%w", err)
    }
    return user, nil
}
\`\`\`

#### API Response
\`\`\`go
func (h *Handler) GetUser(w http.ResponseWriter, r *http.Request) {
    id := chi.URLParam(r, "id")

    user, err := h.service.GetUser(id)
    if err != nil {
        http.Error(w, "User not found", http.StatusNotFound)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(user)
}
\`\`\`

#### Unit Testing
\`\`\`go
func TestGetUser(t *testing.T) {
    // Arrange
    mockRepo := &MockUserRepository{}
    service := NewUserService(mockRepo)

    expectedUser := &User{ID: "1", Name: "John"}
    mockRepo.On("GetByID", "1").Return(expectedUser, nil)

    // Act
    user, err := service.GetUser("1")

    // Assert
    assert.NoError(t, err)
    assert.Equal(t, expectedUser, user)
    mockRepo.AssertExpectations(t)
}
\`\`\`

### 6. Performance Considerations

#### Database Optimization
- Use appropriate indexes
- Implement connection pooling
- Cache frequently accessed data
- Avoid N+1 query problems

#### API Performance
- Implement pagination for large datasets
- Use compression for responses
- Cache static assets
- Monitor response times

### 7. Security Checklist

#### Authentication & Authorization
- [ ] JWT tokens properly validated
- [ ] Passwords hashed with strong algorithm
- [ ] Role-based access control implemented
- [ ] Session management secure

#### Data Protection
- [ ] Input validation on all endpoints
- [ ] SQL injection prevention
- [ ] XSS protection in place
- [ ] Sensitive data encrypted

#### Infrastructure Security
- [ ] HTTPS enabled everywhere
- [ ] Security headers configured
- [ ] Rate limiting implemented
- [ ] Audit logging enabled

### 8. Deployment Checklist

#### Pre-deployment
- [ ] All tests pass in CI/CD
- [ ] Security scan completed
- [ ] Performance benchmarks met
- [ ] Documentation updated

#### Deployment Steps
1. Create deployment branch
2. Run full test suite
3. Build production artifacts
4. Deploy to staging environment
5. Run integration tests
6. Deploy to production
7. Monitor and verify

#### Rollback Plan
- Database backups available
- Previous version tagged
- Rollback scripts tested
- Monitoring alerts configured

### 9. Monitoring & Maintenance

#### Application Monitoring
- Response times and error rates
- Database connection health
- Memory and CPU usage
- Custom business metrics

#### Logging Strategy
- Structured logging with levels
- Request/response logging
- Error tracking and alerting
- Log aggregation and analysis

## Getting Help

### Documentation
- API documentation at \`/docs\`
- Code comments and README files
- Architecture decision records

### Team Communication
- Daily standups for progress updates
- Code reviews for all changes
- Design discussions for major changes
- Pair programming for complex features

---
*Generated by %s agent using Ultimate SDD Framework*`, agent.Role, agent.Role)
}